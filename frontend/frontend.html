<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>frontend</title>
</head>
<body>

    <div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>

    <script>
    
        let fonts = {
            target: 3,
            loaded: 0,
        }

        let roboto_400 = new FontFace("roboto_400", "url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxK.woff2)");
        let roboto_mono_700 = new FontFace("roboto_mono_700", "url(https://fonts.gstatic.com/s/robotomono/v21/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_Of2_ROW4.woff2)");
        let libre_bodoni_700 = new FontFace("libre_bodoni_700", "url(https://fonts.gstatic.com/s/librebodoni/v2/_Xm--H45qDWDYULr5OfyZudXzSBgY2oMBGte6GpY8WvTcQ.woff2)");
        async function font(f, r) {
            await f.load();
            document.fonts.add(f);
            r.loaded += 1;
        }

        font(roboto_400, fonts);
        font(roboto_mono_700, fonts);
        font(libre_bodoni_700, fonts);

        // @TODO
        //update_views() executes like this: animate, link, lock. Then the update_dom() does the rest.

        let time = performance.now();
        let delta = 0;


        // @DONE
        function init_dom() {
            
            let dom = { 
                load: 1,
                
                width: document.documentElement.clientWidth,
                height: document.documentElement.clientHeight,
                
                h: document.head,
                b: document.body,
                e: [] 
            }

            dom.b.style.margin = "0px";
            dom.b.style.padding = "0px";
            dom.b.style.left = "0px";
            dom.b.style.top = "0px";
            dom.b.style.overflow = "hidden";

            let p = document.body.children[0];
            let c = p.children;
            dom.e.push(p);
            
            for (let i = 0; i < c.length; i++) {
                dom.e.push(c[i]);
            }
            for (let i = 0; i < dom.e.length; i++) {
                dom.e[i].style.position = "absolute";
                dom.e[i].style.margin = "0px";
                dom.e[i].style.padding = "0px";
                dom.e[i].style.border = "none";
                dom.e[i].style.left = "0px";
                dom.e[i].style.top = "0px";
                dom.e[i].style.width = "0px";
                dom.e[i].style.height = "0px";
                dom.e[i].style.zIndex = "0";
                dom.e[i].style.overflow = "hidden";
            }

            return dom;
        }

        // FLOAT
        let x0 = 0; // position
        let x1 = 1; // dimension
        let x2 = 2; // rotation
        let x3 = 3; // scale

        let y0 = 4;
        let y1 = 5;
        let y2 = 6;
        let y3 = 7;

        let z0 = 8;
        let z1 = 9;
        let z2 = 10;
        let z3 = 11;

        let opac = 12;
        let bl = 13;
        let cont = 14;
        let satu = 15;
        let gray = 16;
        let brig = 17;
        let sepi = 18;

        let red = 19;
        let green = 20;
        let blue = 21;

        let t_red = 22;
        let t_green = 23;
        let t_blue = 24;
        let t_size = 25;
        
        let b_x0_red = 26;
        let b_x0_green = 27;
        let b_x0_blue = 28;
        let b_x0_size = 29;

        let b_x1_red = 30;
        let b_x1_green = 31;
        let b_x1_blue = 32;
        let b_x1_size = 33;

        let b_y0_red = 34;
        let b_y0_green = 35;
        let b_y0_blue = 36;
        let b_y0_size = 37;

        let b_y1_red = 38;
        let b_y1_green = 39;
        let b_y1_blue = 40;
        let b_y1_size = 41;

        let b_x0_y0_radius = 42;
        let b_x1_y0_radius = 43;
        let b_x1_y1_radius = 44;
        let b_x0_y1_radius = 45;

        let s_red = 46;
        let s_green = 47;
        let s_blue = 48;
        let s_size = 49;
        let s_radius = 50;

        // STRING
        let text = 0;
        let t_font = 1;
        let b_x0 = 2;
        let b_x1 = 3;
        let b_y0 = 4;
        let b_y1 = 5;

        // @ADD clip-path properties

        // @HERE
        function init_views(size) {

            let v = {
                
                state: 0, // view state

                // FLOAT
                f32_s: [], // property state
                f32_c: [], // property current frame
                f32_p: [], // property previous frame

                // LOCK NUMBER
                lop: [], // PROPERTY
                lot: [], // TARGET
                loo: [], // OFFESET
                lomi: [], // MIN
                loma: [], // MAX

                // LINK NUMBER
                lit: [],

                // ANIMATE NUMBER
                ar: [], // RUNNING
                ap: [], // PROGRESS
                at: [], // TIMER
                as: [], // SAMPLE
                ad: [], // DONE

                // STRING
                str_s: [],
                str_c: [],
                str_p: []
            }

            // FLOAT
            for (let i = 0; i < 51; i++) {
                
                v.f32_s.push(new Int8Array(size));
                v.f32_c.push(new Float32Array(size));
                v.f32_p.push(new Float32Array(size));
                v.ar.push(new Int8Array(size));
                v.ap.push(new Float32Array(size));
                v.at.push(new Float64Array(size));
                v.as.push(new Int32Array(size));
                v.ad.push(new Int8Array(size));
            }

            // TRANSFORM
            v.f32_c[x3].fill(1.0);
            v.f32_c[y3].fill(1.0);
            v.f32_c[z3].fill(1.0);
            
            // FILTER
            v.f32_c[opac].fill(100.0);
            v.f32_c[cont].fill(100.0);
            v.f32_c[satu].fill(100.0);
            v.f32_c[brig].fill(100.0);

            // STRING
            for (let i = 0; i < 6; i++) {
                v.str_s.push(new Array(size));
                v.str_s[i].fill("");
                v.str_c.push(new Array(size));
                v.str_c[i].fill("");
                v.str_p.push(new Array(size));
                v.str_p[i].fill("");
            }

            return v;
        }

        // INIT
        let dom = init_dom();
        let v = init_views(dom.e.length);

        // GET VALUE
        function num(p, i) { return v.f32_c[p][i]; }
        function str(p, i) { return v.str_c[p][i]; }

        // SET VALUE
        function _num(p, i, j) { v.f32_c[p][i] = j; }
        function _str(p, i, j) { v.str_c[p][i] = j; }

        // GET STATE
        function num_(p, i) { return v.f32_s[p][i]; }
        function str_(p, i) { return v.str_s[p][i]; }

        // lock()
        // r_lock()
        // link()
        // r_link()
        // anim()
        // r_anim()

        // update_anims()
        // update_links()
        // update_locks()






        // @DONE
        function lock(views, sp, s, tp, t, offset, min, max) {

            v.f32_c[sp][s] = v.f32_c[tp][t] + offset;
            if (min !== null && v.f32_c[sp][s] < min) { v.f32_c[sp][s] = min; }
            else if (max !== null && v.f32_c[sp][s] > max) { v.f32_c[sp][s] = max; }
            return;
        }

        // @DONE
        function link(views, sp, s, tp, t, mult, min, max) {

            if (v.f32_c[tp][t] < v.f32_p[tp][t]) { v.f32_c[sp][s] -= ((v.f32_p[tp][t] - v.f32_c[tp][t]) * mult); }
            else if (v.f32_c[tp][t] > v.f32_p[tp][t]) { v.f32_c[sp][s] += ((v.f32_c[tp][t] - v.f32_p[tp][t]) * mult); }

            if (min !== null && v.f32_c[sp][s] < min) { v.f32_c[sp][s] = min; }
            else if (max !== null && v.f32_c[sp][s] > max) { v.f32_c[sp][s] = max; }
            return;
        }

        function update_links() {

        }

        // @DONE
        function lerp(p0, p1, i) {
            return ((p1 - p0) * i) + p0; 
        }

        // @DONE
        function quad(p0, p1, p2, i) {
            let l0 = lerp(p0, p1, i);
            let l1 = lerp(p1, p2, i);
            return lerp(l0, l1, i);
        }

        // @DONE
        function cube(p0, p1, p2, p3, i) {
            let q0 = quad(p0, p1, p2, i);
            let q1 = quad(p1, p2, p3, i);
            return lerp(q0, q1, i);
        }
        
        // @DONE // refactor into update function??
        function anim(views, sp, s, start, end, time, delay, curve) {

            if (v.ar[sp][s] === 0) {
                v.ad[sp][s] = 0;
                v.ar[sp][s] = 1;
                v.ap[sp][s] = 0.0;
                v.at[sp][s] = 0 - delay;
                v.f32_c[sp][s] = start;
            } 

            // INVERT
            let dir = 1;
            let st = start;
            let en = end;
            if (end < start) { st = end; en = start; dir = -1; }
            let di = en - st;

            // CALCULATE
            v.at[sp][s] += delta;
            if (v.at[sp][s] < 0) { return; }
            let cr = 0;
            if (curve.length === 2) { cr = lerp(curve[0], curve[1], v.at[sp][s] / time); } 
            else if (curve.length === 3) { cr = quad(curve[0], curve[1], curve[2], v.at[sp][s] / time); }
            else if (curve.length === 4) { cr = cube(curve[0], curve[1], curve[2], curve[3], v.at[sp][s] / time); }
            let pr = ((di / time) * delta) * cr;
            v.ap[sp][s] += pr;
            v.f32_c[sp][s] += (pr * dir);

            // DONE
            if (v.ap[sp][s] >= di || v.at[sp][s] >= time) { 
                v.f32_c[sp][s] = end;
                v.ar[sp][s] = 0;
                v.ad[sp][s] = 1;
            }
        }

        function update_dom(dom) {

            dom.width = document.documentElement.clientWidth;
            dom.height = document.documentElement.clientHeight;

            // RESIZE EVENT
            let b = dom.b.getBoundingClientRect();
            if (b.width !== dom.width) {  b.width = dom.width; }
            if (b.height !== dom.height) { b.height = dom.height; }

            let i = 0;
            let len = dom.e.length;

            // @ADD simple diffing algorithm later
            // @ADD if a view contains text it's width and height = "auto"?
            // @ADD if x0 is > rt.width || x1 < 0 do not render display: none (first time then skip rendering subsequent frames)
            // @ADD if y0 is > rt.height || y1 < make element display: none (first time then skip rendering subsequent frames)

            // WIDTH
            while (i < len) { 
                if ((v.f32_c[x1][i] - v.f32_c[x0][i]) !== (v.f32_p[x1][i] - v.f32_p[x0][i])) {
                    dom.e[i].style.width = (v.f32_c[x1][i] - v.f32_c[x0][i]) + "px";
                } i += 1; 
            } 
            
            // HEIGHT
            i = 0;
            while (i < len) {
                if ((v.f32_c[y1][i] - v.f32_c[y0][i]) !== (v.f32_p[y1][i] - v.f32_p[y0][i])) { 
                    dom.e[i].style.height = (v.f32_c[y1][i]- v.f32_c[y0][i]) + "px";
                } i += 1; 
            } 
                
            // TRANSFORM 
            i = 0;
            while (i < len) { 
                dom.e[i].style.transform = 
                    "translate(" + v.f32_c[x0][i] + 
                    "px, " + v.f32_c[y0][i] + "px) " + 
                    "rotate(" + v.f32_c[z2][i] + "deg)" + 
                    "scale(" + v.f32_c[x3][i] + ", " + v.f32_c[y3][i] + ")"; 
                    i += 1; 
            } 
            
            // FILTER
            i = 0;
            while (i < len) {
                
                let update = 0;
                let opacity = "";
                let blur = "";
                let contrast = "";
                let saturate = "";
                let grayscale = "";
                let brightness = "";
                let sepia = "";

                if (v.f32_c[opac][i] !== v.f32_p[opac][i]) { opacity = "opacity(" + v.f32_c[opac][i] + "%) "; update = 1; }
                if (v.f32_c[bl][i] !== v.f32_p[bl][i]) { blur = "blur(" + v.f32_c[bl][i] + "px) "; update = 1; }
                if (v.f32_c[cont][i] !== v.f32_p[cont][i]) { contrast = "contrast(" + v.f32_c[cont][i] + "%) "; update = 1; }
                if (v.f32_c[satu][i] !== v.f32_p[satu][i]) { saturate = "saturate(" + v.f32_c[satu][i] + "%) "; update = 1; }
                if (v.f32_c[gray][i] !== v.f32_p[gray][i]) { grayscale = "grayscale(" + v.f32_c[gray][i] + "%) "; update = 1; }
                if (v.f32_c[brig][i] !== v.f32_p[brig][i]) { brightness = "brightness(" + v.f32_c[brig][i] + "%) "; update = 1; }
                if (v.f32_c[sepi][i] !== v.f32_p[sepi][i]) { sepia = "sepia(" + v.f32_c[sepi][i] + "%) "; update = 1; }
                if (update === 1) { dom.e[i].style.filter = opacity + blur + contrast + saturate + grayscale + brightness + sepia; }    
                i += 1; 
            }
            
            // BACKGROUND COLOR
            i = 0;
            while (i < len) {
                let update = 0;
                if (v.f32_c[red][i] !== v.f32_p[red][i]) { update = 1; }
                if (v.f32_c[green][i] !== v.f32_p[green][i]) { update = 1; }
                if (v.f32_c[blue][i] !== v.f32_p[blue][i]) { update = 1; }
                if (update === 1) { 
                    dom.e[i].style.backgroundColor =
                        "rgb(" + 
                        v.f32_c[red][i] + "," +
                        v.f32_c[green][i] + "," +
                        v.f32_c[blue][i] + ")";
                }
                i += 1;
            }

            // TEXT
            i = 0;
            while (i < len) { 
                if (v.str_c[text][i] !== v.str_p[text][i]) {
                    dom.e[i].textContent = v.str_c[text][i];
                    console.log("yo");
                }
                i += 1;
            }

            // TEXT FONT
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                if (v.str_c[t_font][i] !== v.str_p[t_font][i]) { 
                    dom.e[i].style.fontFamily = v.str_c[t_font][i];
                    console.log(v.str_c[t_font][i]);
                }
                i += 1;
            }

            // TEXT COLOR
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                let update = 0;
                if (v.f32_c[t_red][i] !== v.f32_p[t_red][i]) { update = 1; }
                if (v.f32_c[t_green][i] !== v.f32_p[t_green][i]) { update = 1; }
                if (v.f32_c[t_blue][i] !== v.f32_p[t_blue][i]) { update = 1; }
                if (update === 1) { 
                    dom.e[i].style.color =
                        "rgb(" + 
                        v.f32_c[t_red][i] + "," +
                        v.f32_c[t_green][i] + "," +
                        v.f32_c[t_blue][i] + ")";
                }
                i += 1;
            }

            // TEXT SIZE
            i = 0;
            while (i < len) {
                if (v.str_c[text][i] === "") { i += 1; continue; }
                if (v.f32_c[t_size][i] !== v.f32_p[t_size][i]) { 
                    dom.e[i].style.fontSize = v.f32_c[t_size][i] + "px";
                }
                i += 1;
            }

            // BORDER LEFT

            // BORDER RIGHT

            // BORDER TOP

            // BORDER BOTTOM

            // SHADOW

            // CLEAR EVENTS
            dom.load = 0;
        }

        function clear_dom(dom) {}


        function update_views(rt) {

            _num(x1, 0, rt.width);
            _num(y1, 0, rt.height);

            let curve_line = [0.0, 2.0];
            let curve_quad = [3.0, 0.0, 0.0];
            let curve_cube = [2.0, 0.0, 2.0, 0.0];

            // STATE
            if (v.f32_s[x0][1] === 0 && v.ad[x0][1] === 1) { v.f32_s[x0][1] = 1; }
            else if (v.f32_s[x0][1] === 1 && v.ad[x0][1] === 1) { v.f32_s[x0][1] = 0; }

            // LOAD
            if (rt.load === 1) {
                v.f32_c[x0][1] = 300;
                rt.e[1].style.borderStyle = "none";
                rt.e[1].style.borderRadius = "15px";
                rt.e[1].style.boxShadow = "0px 0.5px 7px rgb(175, 175, 175)";

                rt.e[3].style.borderStyle = "none";
                rt.e[3].style.borderRadius = "0px 0px 15px 15px";
                rt.e[3].style.backgroundColor = "rgb(100, 100, 100)";

                rt.e[2].style.borderStyle = "none";
                rt.e[2].style.boxShadow = "0px 0.5px 7px rgb(175, 175, 175)";

                _str(text, 2, "test");
                _str(t_font, 2, "roboto_400");

                _num(red, 1, 200);
                _num(green, 1, 200);
                _num(blue, 1, 200);

                _num(t_red, 2, 100);
                _num(t_green, 2, 100);
                _num(t_blue, 2, 100);

                _num(t_size, 2, 36);
            }

            // LAYOUT
            lock(v, y0, 1, y0, 0, 300, null, null);
            lock(v, x1, 1, x0, 1, 300, null, null);
            lock(v, y1, 1, y1, 0, -300, null, null);

            //if (num_(x0, 1) === 0) { anim(v, x0, 1, 300, 900, 500, 1000, curve_quad); }
            //else if (num_(x0, 1) === 1) { anim(v, x0, 1, 900, 300, 500, 1000, curve_quad); }

            lock(v, x0, 3, x0, 1, 0, null, null);
            lock(v, x1, 3, x1, 1, 0, null, null);
            lock(v, y1, 3, y1, 1, 0, null, null);
            let a = (num(y1, 1) - num(y0, 1)) / 2;
            lock(v, y0, 3, y0, 1, a, null, null);

            lock(v, x1, 2, x1, 0, 0, null, null);
            lock(v, y1, 2, y0, 0, 100, null, null);
        }

        function clear_views() {
            
            // FLOAT
            for (let i = 0; i < v.f32_c.length; i++) {
                for (let j = 0; j < v.f32_c[i].length; j++) { 
                    if (v.f32_c[i][j] !== v.f32_p[i][j]) { v.f32_p[i][j] = v.f32_c[i][j]; }
                }
            }

            // STRING
            for (let i = 0; i < v.str_c.length; i++) {
                for (let j = 0; j < v.str_c[i].length; j++) { 
                    if (v.str_c[i][j] !== v.str_p[i][j]) { v.str_p[i][j] = v.str_c[i][j]; }
                }
            }
            // CLEAR EVENTS
        }

        function main() {

            let new_time = performance.now();
            delta = new_time - time;
            time = new_time;
            
            if (fonts.loaded === fonts.target) {
                update_views(dom);
                update_dom(dom);
                clear_views();
                clear_dom(dom);
            }

            window.requestAnimationFrame(main);
        }

        main();
    
    </script>
</body>
</html>